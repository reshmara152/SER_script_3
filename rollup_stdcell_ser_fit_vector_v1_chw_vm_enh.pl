#! /usr/intel/bin/perl
################# Intel Corporation Confidential information. ###################
#                                                                                #
# This [insert script name] script as well as the software described in it is         #
# furnished under license and may only be used or copied in accordance with the #
# terms of the license. The information in this manual is furnished for         #
# informational use only, is subject to change without notice, and should not         #
# be construed as a commitment by Intel Corporation. Intel Corporation assumes         #
# no responsibility or liability for any errors or inaccuracies that may appear #
# in this document or any software that may be provided in association with this# 
# document. Except as permitted by such license, no part of this document may be#
# reproduced, stored in a retrieval system, or transmitted in any form or by any#
# means without the express written consent of Intel Corporation.                 #
#                                                                                #
# Copyright ï¿½ 2002 Intel Corporation.                                                 #
#                                                                                          #
################# Intel Corporation Confidential information. ###################

##############################################################################
#version = <version number>  <last date it was modified>  <time it was modified> <by whom>
local ( $SCRIPT_VERSION ) = "v2p5, 2023-11-03";

local ($SCRIPTPATH,$SCRIPTNAME) = $0 =~ /(.*)\/([^\/]+)/;
if (!$SCRIPTPATH) {
    $SCRIPTPATH = ".";
    $SCRIPTNAME = $0 ;
}
local ( $SPACER ) = " "x(length($SCRIPTNAME) + 5);
my( $COMMANDLINE ) = "$SCRIPTNAME " . join ' ', @ARGV;
$| = 1;

$SCRIPT_INFO = "
##############################################################################
 Script: $SCRIPTNAME
 Its version: $SCRIPT_VERSION

 Description:
       This script is to read in hierarchal flops/latches used in a design (this 
    data is generated by the ser_rollup.pl script), and it also reads in QISMAT SOFA
    data of standard cells, then calculates and rolls up SER FIT for all flops/latches 
    used in the design.

 Author:
   Long Pham, long.v.pham\@intel.com

##############################################################################
";
##############################################################################
# History:
#    01/02/2020:  Initial version by Long Pham, long.v.pham@intel.com
#
#    07/12/2021:  (v1.0.1) modified by Long Pham, long.v.pham@intel.com
#         Set QISMAT data for cell Protection and Interleaving to 'None' as default.
#
#        ####  set default PROTECTION and INTERLEAVING to 'None'
#       @linedata[$hdr{PROTECTION}] = @linedata[$hdr{INTERLEAVING}] = "None";
#
#    07/12/2021:  (v1.1.0) modified by Long Pham, long.v.pham@intel.com
#       * Any latch or flop cells with missing FIT data from QISMAT data will be set to the default
#          FIT found from QISMAT data based on latch or flop accordingly. 
#          Algorithm of setting FIT
#            * If the fourth letter in cell name is 'L', that cell FIT will be assigned with LATCH_DEFAULT
#              FIT found in QISMAT data.
#            * All other cells are assigned to FLOP_DEFAULT FIT found from QISMAT data.
#
#    08/06/2021:  (v1.2.0) modified by Long Pham, long.v.pham@intel.com
#        * Added -avf and -tvf options to allow user to set those factors to their product settings
#        * Set FIT for cells which don't have char FIT data to DEFAULT FIT found in QISMAT data based on 
#          CIRCUIT_TOPOLOGY found in QISMAT and the following 10th character in cellname,
#          cell name,
#                    "a", "nom",
#                    "b", "nom",
#                    "c", "nom",
#                    "p", "nom",
#                    "h", "nom",
#                    "x", "RTS",
#                    "y", "RCC",
#                    "z", "SER"
#		12/08/2021  (v1.2.1)	modified by Gabel Chong, gabel.chong@intel.com HSD ticket to include logic tax feature (0.2 default) V 1.2.1 in WW50
#
#	* Added -logictax optional feature to allow user to set that to their product setting
#	If no mentioning of this optional feature in command line, the default logic tax of 0.2
#	is included automatically in the total FIT calucation per SER BKM.
#
#
#
#	  	12/14/2021:  (v1.2.1) modified by Gabel Chong, gabel.chong@intel.com
#			Changing output to go into Static QISMAT worksheet, with these new parameters:
#				*Design style (Flop/latch)
#				*Circuit topology (RTS/STD etc)
#				*Neutron, alpha, thermal neutron and total fit values
#				A column containing the full string of hierarchy with design style with topology against counts, and fits to be rolled up into QISMAT
#
#		5/4/2022: added 3 more columns to be consistent with FUSA needs
#				At this point, input file needs to be checked to ensure GENRAM SCAN_DFX columns are not empty. 
#				If they are, you need to manually insert two columns of zeros.
#       02/21/2024 : (v2.1) modified by Reshma Ravindran Menon, reshma.ravindran.menon@intel.com
#                  - if defaults do not have a combination of parameters along with VECTOR column, the FIT value corresponding to VECTOR 0 is considered for calculating FIT
#                  - Added warning to ensure no 2 entries of same characteristics but different FIT values are present. 
#                  - Added a clause to check if defaults are present for all circuit topologies present in the FIT table. If not, a waring is issued.
#                  - Added a clause to check if alpha, neutron and thermal neutron FIT values are present for each cell definition.
#                  - Added a clause to check if the VECTOR column is present in the FIT table. If not, the vector column gets generated with value 0.
#           
#
##############################################################################
#=============================================================================
# Help menu definition
#=============================================================================

my $DEFAULT_SER_AVF = "0.3";
my $DEFAULT_SER_SEQUENTIAL_TVF = "0.5";
my $DEFAULT_SER_LOGICTAX = "0.2";  # Gabel Added

my( $HELP_MENU ) = "
Script version: $SCRIPT_VERSION
Usage:  $SCRIPTNAME  

        -floplatchdata <file>   Enter a file which contains a list of all hierarchal 
                                flops and latches used in the desgin.
         
        -sofadata <file>        Enter .csv file(s) which contains QISMAT SOFA data for flops
                                and latches. If a design use more than one standard cell
                                types, such as EC0 and E05 for 1274, you can enter two 
                                separate .csv files, one for EC0 and one for E05. Seperate
                                them by comma, no space between them.

                                For example,
                                    file for EC0 library:  I_EC0_x4r1_19ww13_SOFA_runs.csv
                                    file for E05 library:  I_E05_x2r3_18ww22_SOFA_runs.csv
                                                
                                command line for this option,
                                    -sofadata  I_EC0_x4r1_19ww13_SOFA_runs.csv,I_E05_x2r3_18ww22_SOFA_runs.csv 

        -vcc <voltage>          Enter voltage level for SER rollup. This voltage level
                                must exist in QISMAT SOFA data that entered with the '-sofadata' switch.

        -avf <avf_value>        Optional. Use this option to set a specific value for AVF. 
                                If this option is not used at the command line, AVF will be set to $DEFAULT_SER_AVF
								Enter a value as 1.0 for full flow with QISMAT.

        -tvf <tvf_value>        Optional. Use this option to set a specific value for TVF.
                                If this option is not used at the command line, TVF will be set to $DEFAULT_SER_SEQUENTIAL_TVF
								Enter a value as 1.0 for full flow with QISMAT.
								
        -logictax <logictax_value>   Optional. Use this option to set a specific logic tax value.
								Enter value of 0.0 (not merely 0) for full flow with QISMAT, or if you do not want to include logictax.
								If this option is not used at the command line, logictax will be set to $DEFAULT_SER_LOGICTAX

        [-help]					Print out this help menu.

";

##############################################################################
#=============================================================================
# Initialization package used and variables
#=============================================================================
#
use Getopt::Long;
use List::MoreUtils qw(uniq);
#use warnings;
#my $SER_VCC = "0.8";
my $SER_PROTECTION = "None";
my $SER_INTERLEAVING = "None";
my $SER_CAP_LOAD = "NOM";
my $SER_FIT_TYPE = "ALPHA_MEAN";       ## Gabel added this this variable and initialized value
my $SER_TEMPERATURE = "110";
my $SER_ALTITUDE = "0.9";
my $SER_MEMORY_TVF = "1.0";



##############################################################################

BEGIN {

}

END {

}

##############################################################################
#=============================================================================
# Main code starts here
#=============================================================================

parse_cmd_line();
foreach my $file (split(/,/,$SOFA_DATA_FILE)) {
    parse_sofa_fit_data($file);
}
parse_floplatch_design_data($FLOPLATCH_LIST_FILE);
print "To view log in EXCEL, open ser_fit_rollup_*flop_latch.log file using comma (,) and space as delimiters.\n";
print "If continuing with flow to processing_QISMAT.pl, do not change ser_fit_rollup_*flop_latch.log file or format.\n\n"; 

print "Total product FIT NEUTRON:  $total_product_Neutron_FIT\n";
print "Total product FIT ALPHA:  $total_product_Alpha_FIT\n";
print "Total product FIT THERMAL NEUTRON:  $total_product_Thermal_FIT\n";
print "Total product FIT:  $total_product_FIT\n\n";

exit(0);

##############################################################################
#=============================================================================
# Subroutines start here
#=============================================================================
#############################
sub parse_floplatch_design_data {
#############################
    my ($floplatch_design_file)=@_;
    my $filename = `basename $floplatch_design_file`;
    $filename =~s/_rollup\.hier_info//;
    print "$SCRIPTNAME -I-: Parsing flop/latch design data, $floplatch_design_file...........\n";
    open(INFILE,"$floplatch_design_file") || die "\n$SCRIPTNAME -E-: Can't read flop/latch design data file, $floplatch_design_file\n\n";
    open(OUTFILE,">ser_fit_rollup_$filename") || die "$SCRIPTNAME -E-: Can't create flop/latch FIT data rollup file, ser_fit_rollup_$filename\n\n";
    while (<INFILE>) { s/^\s*|\s*$//g;
		$line = $_;
        if (/ Cell_cnt /) {
            print OUTFILE "$line hier_info,Design_Style,Circuit_Topology Cell_Cnt AVF TVF Neutron_fit Alpha_fit Th_Neutron_fit Final_Total_FIT CellFit(FuSa) AVF(FuSa) TVF(FuSa) Final_Total_FIT(FuSa)\n";
            $found_sofa_data=1;
            my @hdrs=split(/\s+/,$_);
            for ($i=0;$i<=$#hdrs;$i++) {
                $hdr{@hdrs[$i]}=$i;
            }
            next;
        } else {
			
			my @linedata=split(/\s+/,$_);
			my $hier=  @linedata[0]; substr($hier,-17)='';
			my $cell = @linedata[0]; $cell=~s/.*\///g;
            my $cellcnt = @linedata[$hdr{Cell_cnt}];		
			my $genram = @linedata[$hdr{GENRAM}]  ;# ||'0'; 			
			my $scan_dfx = @linedata[$hdr{SCAN_DFX}]; # ||'0';
 
                ######### Gabel added @linedatafor circuit_topology; and new $design_style variable
            my $circuit_topology; # @linedata[$hdr{CIRCUIT_TOPOLOGY}];                
            my $design_style; #  @linedata[$hdr{DESIGN_STYLE}];        
            
			my $cellFit;
            my $cellFit_Neutron;
			my $cellFit_Alpha;
			my $cellFit_Thermal;
			
            ########  cell type based on 10th character in cellname
            #    "a", "nom",
            #    "b", "nom",
            #    "c", "nom",
            #    "p", "nom",
             #    "h", "nom",
             #    "x", "RTS",
            #    "y", "RCC",
            #    "z", "SER"

            if ($cell =~ /^\w{9}x/i) {                 ####    "x", "RTS"
                $circuit_topology = "RTS";
            } elsif ($cell =~ /^\w{9}y/i) {         ####    "y", "RCC"
                $circuit_topology = "RCC";
            } elsif ($cell =~ /^\w{9}z/i) {         ####    "z", "SER"
                $circuit_topology = "SER";
            } elsif ($cell =~ /^\w{9}[abcph]/i) {         ####    "?", "nom"
                $circuit_topology = "STD";
            } else {
                $circuit_topology = "STD";
            }
                
                ###### Design style type based on 3th character in cellname -Gabel added this variable to be printed 
            if ($cell =~ /^\w{3}c?f/) {                 ####   "f", "FLOP"
                $design_style = "FLOP";
            } elsif ($cell =~ /^\w{3}l|cil[ab]/) {
                $design_style = "LATCH"; 
            } else {
                $design_style = "UNKNOWN";
            }

            my $VECTOR = substr($cell, 6, 1);
            
            # print "DEBUG: cell>>>" . $cell . "\n";
            if ($stdcellFIT{$cell}{$SER_VCC}{$SER_PROTECTION}{$SER_INTERLEAVING}{$SER_CAP_LOAD}{$SER_FIT_TYPE}{$SER_TEMPERATURE}{$SER_ALTITUDE}) {
                    $cellFit_Neutron = $stdcellFIT{$cell}{$SER_VCC}{$SER_PROTECTION}{$SER_INTERLEAVING}{$SER_CAP_LOAD}{NEUTRON_MEAN}{$SER_TEMPERATURE}{$SER_ALTITUDE}; ## make 3 version cell
                    $cellFit_Alpha = $stdcellFIT{$cell}{$SER_VCC}{$SER_PROTECTION}{$SER_INTERLEAVING}{$SER_CAP_LOAD}{ALPHA_MEAN}{$SER_TEMPERATURE}{$SER_ALTITUDE}; ## make 3 version cell
                    $cellFit_Thermal = $stdcellFIT{$cell}{$SER_VCC}{$SER_PROTECTION}{$SER_INTERLEAVING}{$SER_CAP_LOAD}{THERMAL_NEUTRON_MEAN}{$SER_TEMPERATURE}{$SER_ALTITUDE}; ## make 3 version cell
                    
				$cellFit= $cellFit_Neutron + $cellFit_Alpha + $cellFit_Thermal;
			} else {  ### cell doesn't have FIT data in QISMAT, set FIT for those cells to DEFAULT settings found in QISMAT data
                if ($design_style eq "FLOP") {  ### flop
                # also 3x this line:
                        if ( exists $stdcellFIT{"FLOP-DEFAULT"}{$circuit_topology}{$SER_VCC}{$SER_PROTECTION}{$SER_INTERLEAVING}{$SER_CAP_LOAD}{$SER_FIT_TYPE}{$SER_TEMPERATURE}{$SER_ALTITUDE}{$VECTOR})
                        {
                            $cellFit_Neutron = $stdcellFIT{"FLOP-DEFAULT"}{$circuit_topology}{$SER_VCC}{$SER_PROTECTION}{$SER_INTERLEAVING}{$SER_CAP_LOAD}{NEUTRON_MEAN}{$SER_TEMPERATURE}{$SER_ALTITUDE}{$VECTOR};
                            $cellFit_Alpha = $stdcellFIT{"FLOP-DEFAULT"}{$circuit_topology}{$SER_VCC}{$SER_PROTECTION}{$SER_INTERLEAVING}{$SER_CAP_LOAD}{ALPHA_MEAN}{$SER_TEMPERATURE}{$SER_ALTITUDE}{$VECTOR};
                            $cellFit_Thermal = $stdcellFIT{"FLOP-DEFAULT"}{$circuit_topology}{$SER_VCC}{$SER_PROTECTION}{$SER_INTERLEAVING}{$SER_CAP_LOAD}{THERMAL_NEUTRON_MEAN}{$SER_TEMPERATURE}{$SER_ALTITUDE}{$VECTOR};
                            
                        } else {

                            $cellFit_Neutron = $stdcellFIT{"FLOP-DEFAULT"}{$circuit_topology}{$SER_VCC}{$SER_PROTECTION}{$SER_INTERLEAVING}{$SER_CAP_LOAD}{NEUTRON_MEAN}{$SER_TEMPERATURE}{$SER_ALTITUDE}{"0"};
                            $cellFit_Alpha = $stdcellFIT{"FLOP-DEFAULT"}{$circuit_topology}{$SER_VCC}{$SER_PROTECTION}{$SER_INTERLEAVING}{$SER_CAP_LOAD}{ALPHA_MEAN}{$SER_TEMPERATURE}{$SER_ALTITUDE}{"0"};
                            $cellFit_Thermal = $stdcellFIT{"FLOP-DEFAULT"}{$circuit_topology}{$SER_VCC}{$SER_PROTECTION}{$SER_INTERLEAVING}{$SER_CAP_LOAD}{THERMAL_NEUTRON_MEAN}{$SER_TEMPERATURE}{$SER_ALTITUDE}{"0"};          
                            }
                $cellFit= $cellFit_Neutron + $cellFit_Alpha + $cellFit_Thermal;

                } elsif ($design_style eq "LATCH")  { ### latch
                # also 3x this line:
                        if ( exists $stdcellFIT{"LATCH-DEFAULT"}{$circuit_topology}{$SER_VCC}{$SER_PROTECTION}{$SER_INTERLEAVING}{$SER_CAP_LOAD}{$SER_FIT_TYPE}{$SER_TEMPERATURE}{$SER_ALTITUDE}{$VECTOR})
                        {
                            $cellFit_Neutron = $stdcellFIT{"LATCH-DEFAULT"}{$circuit_topology}{$SER_VCC}{$SER_PROTECTION}{$SER_INTERLEAVING}{$SER_CAP_LOAD}{NEUTRON_MEAN}{$SER_TEMPERATURE}{$SER_ALTITUDE}{$VECTOR};
						    $cellFit_Alpha = $stdcellFIT{"LATCH-DEFAULT"}{$circuit_topology}{$SER_VCC}{$SER_PROTECTION}{$SER_INTERLEAVING}{$SER_CAP_LOAD}{ALPHA_MEAN}{$SER_TEMPERATURE}{$SER_ALTITUDE}{$VECTOR};
						    $cellFit_Thermal = $stdcellFIT{"LATCH-DEFAULT"}{$circuit_topology}{$SER_VCC}{$SER_PROTECTION}{$SER_INTERLEAVING}{$SER_CAP_LOAD}{THERMAL_NEUTRON_MEAN}{$SER_TEMPERATURE}{$SER_ALTITUDE}{$VECTOR};
                            
                        } else {

                            $cellFit_Neutron = $stdcellFIT{"LATCH-DEFAULT"}{$circuit_topology}{$SER_VCC}{$SER_PROTECTION}{$SER_INTERLEAVING}{$SER_CAP_LOAD}{NEUTRON_MEAN}{$SER_TEMPERATURE}{$SER_ALTITUDE}{"0"};
                            $cellFit_Alpha = $stdcellFIT{"LATCH-DEFAULT"}{$circuit_topology}{$SER_VCC}{$SER_PROTECTION}{$SER_INTERLEAVING}{$SER_CAP_LOAD}{ALPHA_MEAN}{$SER_TEMPERATURE}{$SER_ALTITUDE}{"0"};
                            $cellFit_Thermal = $stdcellFIT{"LATCH-DEFAULT"}{$circuit_topology}{$SER_VCC}{$SER_PROTECTION}{$SER_INTERLEAVING}{$SER_CAP_LOAD}{THERMAL_NEUTRON_MEAN}{$SER_TEMPERATURE}{$SER_ALTITUDE}{"0"};

                        }
                $cellFit= $cellFit_Neutron + $cellFit_Alpha + $cellFit_Thermal;
                } else {
                    print "WARNING: NEITHER FLOP NOR LATCH: " . $cell . "\n";
                }
            }




	
           my $tvf = $genram?$SER_MEMORY_TVF:$SER_SEQUENTIAL_TVF;

           if ($stdcellFIT{$cell}{$SER_VCC}) {
								
              if ($cellFit) {					# NOT SURE WHAT TO DO WITH THIS SET

					   $line .= " $hier,,,,,,,,,,";
                       $line .="$design_style"; 
                       $line .=","; 
                       $line .="$circuit_topology  ";  # Gabel Added design style and circuit topology

				} else {
                        $line .= "0"; 
                }           
				

                $line .= "$cellcnt"; 

		   if (!$scan_dfx)  {

                   $line .= "  $SER_AVF  $tvf  "; 
					
					$line .= sprintf "%.9f ",$cellFit_Neutron*$cellcnt*$SER_AVF*($tvf+$SER_LOGICTAX); ## Gabel Added
                    $line .= sprintf "%.9f ",$cellFit_Alpha*$cellcnt*$SER_AVF*($tvf+$SER_LOGICTAX); ## Gabel Added
                    $line .= sprintf "%.9f ",$cellFit_Thermal*$cellcnt*$SER_AVF*($tvf+$SER_LOGICTAX); ## Gabel Added

				   
                   $total_product_Neutron_FIT += sprintf "%.9f",$cellFit_Neutron*$cellcnt*$SER_AVF*($tvf+$SER_LOGICTAX);
                   $total_product_Alpha_FIT += sprintf "%.9f",$cellFit_Alpha*$cellcnt*$SER_AVF*($tvf+$SER_LOGICTAX);
                   $total_product_Thermal_FIT += sprintf "%.9f",$cellFit_Thermal*$cellcnt*$SER_AVF*($tvf+$SER_LOGICTAX);
				   
					$total_product_FIT += sprintf "%.9f", ($cellFit)*$cellcnt*$SER_AVF*($tvf+$SER_LOGICTAX) ;			   				
					$line .= sprintf "%.9f ",($cellFit)*$cellcnt*$SER_AVF*($tvf+$SER_LOGICTAX) ;
				
					$line .= sprintf "%.9f ",$cellFit*$cellcnt; 								 # for FUSA  
					$line .= "  $SER_AVF  $tvf  ";  											# for FUSA
					$line .= sprintf "%.9f ",($cellFit)*$cellcnt*$SER_AVF*($tvf+$SER_LOGICTAX);	 # for FUSA		
               } else {
                   $line .= " 0.0	$tvf  ";		   
					$line .= sprintf "%.9f ",$cellFit_Neutron*$cellcnt*0*($tvf+$SER_LOGICTAX); ## Gabel Added
                    $line .= sprintf "%.9f ",$cellFit_Alpha*$cellcnt*0*($tvf+$SER_LOGICTAX); ## Gabel Added
                    $line .= sprintf "%.9f ",$cellFit_Thermal*$cellcnt*0*($tvf+$SER_LOGICTAX); ## Gabel Added
				    $line .= sprintf "%.9f ",($cellFit)*$cellcnt*0*($tvf+$SER_LOGICTAX) ;	##Gabel Added
					
					$line .= sprintf "%.9f ",$cellFit*$cellcnt;  									# for FUSA 
					$line .= "   0.0  $tvf  ";													# for FUSA
					$line .= "  0.0 "	;															# for FUSA	
					
					
               }
           } else {
               if (!$scan_dfx ) {
                       $line .= "0	0	$SER_AVF  $tvf	0";
               } else {
                       $line .= "0	0	$tvf	0";
               }
          }
             print OUTFILE "$line\n";        

        }
    } close(INFILE); close(OUTFILE);
    print "$SCRIPTNAME -I-: Finished rolling up SER FIT for sequential cells used in the design.\n$SPACER See, ser_fit_rollup_$filename\n\n";
}

#############################
sub parse_sofa_fit_data {
# $SER_PROTECTION = "None";
# $SER_INTERLEAVING = "None";
# $SER_CAP_LOAD = "NOM";
# $SER_TEMPERATURE = "110";
# $SER_ALTITUDE = "0.9";
#############################
    my ($sofa_file)=@_; #$sofa_file is a variable, @_ = extract first element from the array. in this case since it is inside a subroutine, it holds the value of the arguements passed to the subroutine. in this case, the sofa file is passed
    open(INFILE,"$sofa_file") || die "\n$SCRIPTNAME -E-: Can't read QISMAT SOFA data file, $sofa_file\n\n";
    print "$SCRIPTNAME -I-: Parsing QISMAT SOFA data for flops/latches, $sofa_file...........\n";
    my ($found_sofa_data)=0;
    my ($found_specific_vcc_sofa_data)=0;
    my ($vector_column_absent) = 0;
    @ckt_topology = ();
    while (<INFILE>) { 
        
        s/^\s*|\s*$//g;
        if (/^\s*FIT_INDEX/) {
            $found_sofa_data=1;
            my @hdrs=split(/,/,$_); #@hdrs is an array, this splits the string using comma as delimiter and stores the substrings in the array @hdrs. 
            
            # Check if vector column is present in the FIT table or not. 
            if (! grep {$_ eq 'VECTOR'} @hdrs) {
                $vector_column_absent = 1;
                push (@hdrs, "VECTOR");
            }
            
            for ($i=0;$i<=$#hdrs;$i++) {
                $hdr{@hdrs[$i]}=$i; # creates a hash where the keys are the header values and the values are the indices; hdr is a hash 
                
            }            
            next;
        
        }
        my @linedata=split(/,/,$_); #linedata is an array, this splits the string using , as delimited and stores the substrings in the array linedata.

        ####  set default PROTECTION and INTERLEAVING to 'None'
        @linedata[$hdr{PROTECTION}] = @linedata[$hdr{INTERLEAVING}] = "None"; #trying to access an element in the array @linedata using the index obtained from the PROTECTION column, fetches the index of PROTECTION from has hdr

        # if vector column is not present, the vector column gets generated with value "0"
        if ($vector_column_absent) {
            @linedata[$hdr{VECTOR}] = 0;
           
        }

        if ($found_sofa_data) {
            my $vcc = sprintf "%.2f",@linedata[$hdr{VCC}]; #getting the value of VCC from the hash table and assigning it to variable vcc
            $found_specific_vcc_sofa_data=1 if ($vcc eq $SER_VCC);

            push(@ckt_topology,@linedata[$hdr{CIRCUIT_TOPOLOGY}]); 
            @ckt_topology = uniq @ckt_topology;
            
               
            if (@linedata[$hdr{CELL_TYPE}] =~ /FLOP\-DEFAULT/i) {
                # "if" clauses added to check if entry already exists for the same combination of parameters with same FIT values. 
                # use cell name FLOP-DEFAULT instead of default
                if (exists $stdcellFIT{"FLOP-DEFAULT"}{@linedata[$hdr{CIRCUIT_TOPOLOGY}]}{$vcc}{@linedata[$hdr{PROTECTION}]}{@linedata[$hdr{INTERLEAVING}]}{@linedata[$hdr{CAP_LOAD}]}{@linedata[$hdr{FIT_TYPE}]}{@linedata[$hdr{TEMPERATURE}]}{@linedata[$hdr{ALTITUDE}]}{@linedata[$hdr{VECTOR}]}) {
                    print "WARNING : Entry already exists \n" ;
                    print join(",",@linedata) . "\n";
                }
                $stdcellFIT{"FLOP-DEFAULT"}{@linedata[$hdr{CIRCUIT_TOPOLOGY}]}{$vcc}{@linedata[$hdr{PROTECTION}]}{@linedata[$hdr{INTERLEAVING}]}{@linedata[$hdr{CAP_LOAD}]}{@linedata[$hdr{FIT_TYPE}]}{@linedata[$hdr{TEMPERATURE}]}{@linedata[$hdr{ALTITUDE}]}{@linedata[$hdr{VECTOR}]} = @linedata[$hdr{FIT}];

            } elsif  (@linedata[$hdr{CELL_TYPE}] =~ /LATCH\-DEFAULT/i) {
                # use cell name LATCH-DEFAULT instead of default
                if (exists $stdcellFIT{"LATCH-DEFAULT"}{@linedata[$hdr{CIRCUIT_TOPOLOGY}]}{$vcc}{@linedata[$hdr{PROTECTION}]}{@linedata[$hdr{INTERLEAVING}]}{@linedata[$hdr{CAP_LOAD}]}{@linedata[$hdr{FIT_TYPE}]}{@linedata[$hdr{TEMPERATURE}]}{@linedata[$hdr{ALTITUDE}]}{@linedata[$hdr{VECTOR}]}) {
                    print "WARNING : Entry already exists \n" ;
                    print join(",",@linedata) . "\n";
                }
                $stdcellFIT{"LATCH-DEFAULT"}{@linedata[$hdr{CIRCUIT_TOPOLOGY}]}{$vcc}{@linedata[$hdr{PROTECTION}]}{@linedata[$hdr{INTERLEAVING}]}{@linedata[$hdr{CAP_LOAD}]}{@linedata[$hdr{FIT_TYPE}]}{@linedata[$hdr{TEMPERATURE}]}{@linedata[$hdr{ALTITUDE}]}{@linedata[$hdr{VECTOR}]} = @linedata[$hdr{FIT}];

            } else {
                if (exists $stdcellFIT{@linedata[$hdr{NAME}]}{$vcc}{@linedata[$hdr{PROTECTION}]}{@linedata[$hdr{INTERLEAVING}]}{@linedata[$hdr{CAP_LOAD}]}{@linedata[$hdr{FIT_TYPE}]}{@linedata[$hdr{TEMPERATURE}]}{@linedata[$hdr{ALTITUDE}]}) {
                    print "WARNING : Entry already exists \n" ;
                    print join(",",@linedata) . "\n";
                }
                $stdcellFIT{@linedata[$hdr{NAME}]}{$vcc}{@linedata[$hdr{PROTECTION}]}{@linedata[$hdr{INTERLEAVING}]} {@linedata[$hdr{CAP_LOAD}]}{@linedata[$hdr{FIT_TYPE}]}{@linedata[$hdr{TEMPERATURE}]}{@linedata[$hdr{ALTITUDE}]} = @linedata[$hdr{FIT}];  # Gabel Adding this {@linedata[$hdr{FIT_TYPE}]}

            }

            
        }
    }close(INFILE);

    # Function to check if defaults are present for all circuit topologies
    fit_table_chk_for_flop_latch_default_ckt_topology(%stdcellFIT);
    
    # Function to check for every cell definition,  alpha, neutron and thermal neutron FIT values are present. 
    fit_table_chk_fittype_for_each_cell_definition(%stdcellFIT);


    if ($found_specific_vcc_sofa_data) {
    print "    -I-: Found ${SER_VCC}V data in QISMAT SOFA file.\n\n";

    # use JSON;
    # warn to_json(\%stdcellFIT, {canonical=>1, pretty=>1});
    for_debug_for_defaults(%stdcellFIT);
    
    } else {
        die "\n$SCRIPTNAME -E-: No ${SER_VCC}V data found in QISMAT SOFA file, $sofa_file.\n\n";
    }
}

#############################
sub fit_table_chk_for_flop_latch_default_ckt_topology {
# to check if a default flop and latch is present for every circuit topology
#############################     

    foreach my $celltype (grep (/DEFAULT$/, keys %stdcellFIT )) {
        
        # putting all cirtuit topologies into an array
        foreach my $ckttopology (@ckt_topology) {
            foreach my $volt (keys %{$stdcellFIT{$celltype}{$ckttopology}}) {
                foreach my $protection (keys %{$stdcellFIT{$celltype}{$ckttopology}{$volt}}) {
                    foreach my $interleaving (keys %{$stdcellFIT{$celltype}{$ckttopology}{$volt}{$protection}}) {
                        foreach my $capload (keys %{$stdcellFIT{$celltype}{$ckttopology}{$volt}{$protection}{$interleaving}}) {
                            foreach my $fittype (keys %{$stdcellFIT{$celltype}{$ckttopology}{$volt}{$protection}{$interleaving}{$capload}}) {
                                foreach my $temperature (keys %{$stdcellFIT{$celltype}{$ckttopology}{$volt}{$protection}{$interleaving}{$capload}{$fittype}}) {
                                    foreach my $altitude (keys %{$stdcellFIT{$celltype}{$ckttopology}{$volt}{$protection}{$interleaving}{$capload}{$fittype}{$temperature}}) {
                                        foreach my $vector (keys %{$stdcellFIT{$celltype}{$ckttopology}{$volt}{$protection}{$interleaving}{$capload}{$fittype}{$temperature}{$altitude}}) {                                           
                                            # print "$stdcellFIT{$celltype}{$ckttopology}{$volt}{$protection}{$interleaving}{$capload}{$fittype}{$temperature}{$altitude}{$vector}\n";
                                            if (! exists $stdcellFIT{$celltype}{$ckttopology}{$volt}{$protection}{$interleaving}{$capload}{$fittype}{$temperature}{$altitude}{"0"}) {
                                                print "WARNING : Default Flop/Latch $celltype not defined for ckt topology <$ckttopology>\n" ;
                                            }
                                        }
                                    }
                                }
                            }

                        }
                    }
                }

            }
        }
            
    }

}

#############################
sub fit_table_chk_fittype_for_each_cell_definition {
# to check if a default flop and latch is present for every circuit topology
#############################   


    foreach my $celltype (keys %stdcellFIT){
        foreach my $ckttopology (keys %{$stdcellFIT{$celltype}}) {
            foreach my $volt (keys %{$stdcellFIT{$celltype}{$ckttopology}}) {
                foreach my $protection (keys %{$stdcellFIT{$celltype}{$ckttopology}{$volt}}) {
                    foreach my $interleaving (keys %{$stdcellFIT{$celltype}{$ckttopology}{$volt}{$protection}}) {
                        foreach my $capload (keys %{$stdcellFIT{$celltype}{$ckttopology}{$volt}{$protection}{$interleaving}}) {
                            foreach my $fittype (keys %{$stdcellFIT{$celltype}{$ckttopology}{$volt}{$protection}{$interleaving}{$capload}}) {
                                foreach my $temperature (keys %{$stdcellFIT{$celltype}{$ckttopology}{$volt}{$protection}{$interleaving}{$capload}{$fittype}}) {
                                    foreach my $altitude (keys %{$stdcellFIT{$celltype}{$ckttopology}{$volt}{$protection}{$interleaving}{$capload}{$fittype}{$temperature}}) {
                                        foreach my $vector (keys %{$stdcellFIT{$celltype}{$ckttopology}{$volt}{$protection}{$interleaving}{$capload}{$fittype}{$temperature}{$altitude}}) {
                                            $stdcellFIT_new{$celltype}{$ckttopology}{$volt}{$protection}{$interleaving}{$capload}{$temperature}{$altitude}{$vector}{$fittype} = $stdcellFIT{$celltype}{$ckttopology}{$volt}{$protection}{$interleaving}{$capload}{$fittype}{$temperature}{$altitude}{$vector};                                           
                                        }
                                    }
                                }
                            }

                        }
                    }
                }

            }
        }
            
    }    

    foreach my $celltype (keys %stdcellFIT_new) {
        foreach my $ckttopology (keys %{$stdcellFIT_new{$celltype}})   {
            foreach my $volt (keys %{$stdcellFIT_new{$celltype}{$ckttopology}}) {
                foreach my $protection (keys %{$stdcellFIT_new{$celltype}{$ckttopology}{$volt}}) {
                    foreach my $interleaving (keys %{$stdcellFIT_new{$celltype}{$ckttopology}{$volt}{$protection}}) {
                        foreach my $capload (keys %{$stdcellFIT_new{$celltype}{$ckttopology}{$volt}{$protection}{$interleaving}}) {
                            foreach my $temperature (keys %{$stdcellFIT_new{$celltype}{$ckttopology}{$volt}{$protection}{$interleaving}{$capload}}) {
                                foreach my $altitude (keys %{$stdcellFIT_new{$celltype}{$ckttopology}{$volt}{$protection}{$interleaving}{$capload}{$temperature}}) {
                                    foreach my $vector (keys %{$stdcellFIT_new{$celltype}{$ckttopology}{$volt}{$protection}{$interleaving}{$capload}{$temperature}{$altitude}}) {
                                        foreach my $fittype (("NEUTRON_MEAN","ALPHA_MEAN", "THERMAL_NEUTRON_MEAN")) {
                                            if (! exists $stdcellFIT_new{$celltype}{$ckttopology}{$volt}{$protection}{$interleaving}{$capload}{$temperature}{$altitude}{$vector}{$fittype}) {
                                            print "$fittype is missing for $celltype for circuit topology $ckttopology for $volt for $vector \n";
                                            }
                                        
                                            
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
                                    
}
    
#############################
sub for_debug_for_defaults {
        if (0) { ######### for debug only
    foreach my $celltype (keys %stdcellFIT) {
        next if ($celltype !~ /DEFAULT$/);
        print "celltype:  <$celltype>\n";
        foreach my $volt (keys %{$stdcellFIT{$celltype}}) {
            foreach my $protection (keys %{$stdcellFIT{$celltype}{$volt}}) {
                foreach my $interleaving (keys %{$stdcellFIT{$celltype}{$volt}{$protection}}) {
                    foreach my $capload (keys %{$stdcellFIT{$celltype}{$volt}{$protection}{$interleaving}}) {
                                    foreach my $fittype (keys %{$stdcellFIT{$celltype}{$volt}{$protection}{$interleaving}{$capload}}) {
                                            foreach my $temperature (keys %{$stdcellFIT{$celltype}{$volt}{$protection}{$interleaving}{$capload}{$fittype}}) {
                                                    foreach my $altitude (keys %{$stdcellFIT{$celltype}{$volt}{$protection}{$interleaving}{$capload}{$fittype}{$temperature}}) {
                                print "vcc: <$volt>\n";
                                print "stdcellFIT{$celltype}{$volt}{$protection}{$interleaving}{$capload}{$fittype}{$temperature}{$altitude}:  $stdcellFIT{$celltype}{$volt}{$protection}{$interleaving}{$capload}{$fittype}{$temperature}{$altitude}\n";
                                    }
                                    }
                            }
                        }
                    }
                }
            }
        }        
    }
}


#############################
sub parse_cmd_line {
#############################
    my( @options );

    die "Use -help option to see all the options.\n" unless \
    GetOptions ('floplatchdata=s' => \$FLOPLATCH_LIST_FILE,
                'sofadata=s' => \$SOFA_DATA_FILE,
                'vcc=s'                => \$SER_VCC,
                'avf=s'                => \$USER_AVF_SETTING,
                'tvf=s'                => \$USER_TVF_SETTING,
				'logictax=s'	=> \$USER_LOGICTAX_SETTING,
                'scinfo'        => \$opt_scinfo,
                'help'          => \$opt_help );

    if ($opt_help) {
        print "$HELP_MENU\n"; exit(0);
    }
    if ($opt_scinfo) {
        print "$SCRIPT_INFO\n"; exit(0);
    }
    print "Command line: $COMMANDLINE\n";

    ### Start parsing command line for other option(s) from here
    die "\n$SCRIPTNAME -E-: A file contains a list of all hierarchal flops and latches used in the desgin is required. Please use the '-floplatchdata <file>' option.\n\n" if (!$FLOPLATCH_LIST_FILE);
    die "\n$SCRIPTNAME -E-: A file contains SOFA data of standard cells is required. Please use the '-sofadata <file>' option.\n\n" if (!$SOFA_DATA_FILE);
    if (!$SER_VCC) {
            die "\n$SCRIPTNAME -E-: A specific VCC voltage is required for the rollup. This voltage level must exist in QISMAT SOFA data. Please use the '-vcc <value>' option.\n\n";
    } else {
        $SER_VCC = sprintf"%.2f",$SER_VCC;
    }

    if ($USER_AVF_SETTING) {
        if ($USER_AVF_SETTING!~/^\d*\.\d+$/ or $USER_AVF_SETTING>1) {
            die "\n$SCRIPTNAME -E-: Invalid setting for AVF, '$USER_AVF_SETTING'\n$SPACER It should be a real number and less than '1'.\n";
        }
    }
    if ($USER_TVF_SETTING) {
        if ($USER_TVF_SETTING!~/^\d*\.\d+$/ or $USER_TVF_SETTING>1) {
            die "\n$SCRIPTNAME -E-: Invalid setting for TVF, '$USER_TVF_SETTING'\n$SPACER It should be a real number and less than '1'.\n";
        }
    }
        
	    if ($USER_LOGICTAX_SETTING) {
	if ($USER_LOGICTAX_SETTING!~/^\d*\.\d+$/ or $USER_LOGICTAX_SETTING>=1) {
	    die "\n$SCRIPTNAME -E-: Invalid setting for LOGICTAX, '$USER_LOGICTAX_SETTING'\n$SPACER It should be a real number and less than '1'.\n ";
		}
    } 
	 
	 
	 
	 
    $SER_AVF=$USER_AVF_SETTING?$USER_AVF_SETTING:$DEFAULT_SER_AVF;
    $SER_SEQUENTIAL_TVF=$USER_TVF_SETTING?$USER_TVF_SETTING:$DEFAULT_SER_SEQUENTIAL_TVF;
	$SER_LOGICTAX=$USER_LOGICTAX_SETTING?$USER_LOGICTAX_SETTING:$DEFAULT_SER_LOGICTAX; # DEFAULT_SER_LOGICTAX SER_LOGICTAX LOGICTAX USER_LOGICTAX_SETTING
 
}
